import SwiftUI
import Combine

extension View {
    func placeholder<Content: View>(
        when shouldShow: Bool,
        alignment: Alignment = .center,
        @ViewBuilder placeholder: () -> Content
    ) -> some View {
        ZStack(alignment: alignment) {
            placeholder().opacity(shouldShow ? 1 : 0)
            self
        }
    }
}

@MainActor
struct ContentView: View {
    @State private var searchText = ""
    @State private var selectedWord: Word?
    @State private var showingEtymology = false
    @State private var loadingState: LoadingState = .idle
    @State private var searchHistory: [String] = UserDefaults.standard.stringArray(forKey: "searchHistory") ?? []
    @State private var remarkableWords: [RemarkableWord] = []
    @State private var isLoadingRemarkableWords = false
    @State private var composedWords: [Word] = []
    @State private var showingComposedWords = false
    @State private var showingCuration = false
    
    @FocusState private var isSearchFieldFocused: Bool
    @StateObject private var curator = RemarkableWordsCurator.shared
    @Environment(\.colorScheme) var colorScheme
    @State private var showNoResultMessage = false
    
    private func performSearch() {
        guard !searchText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        
        let wordToSearch = searchText.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        withAnimation(.easeInOut(duration: 0.3)) {
            isSearchFieldFocused = false
        }
        
        Task {
            do {
                await MainActor.run {
                    loadingState = .loadingWord
                }
                
                // V√©rifier si le mot existe d√©j√†
                if let existingWord = try await SupabaseService.shared.fetchWord(wordToSearch) {
                    await MainActor.run {
                        loadingState = .idle
                        addToHistory(wordToSearch)
                        
                        if existingWord.isComposedWord && existingWord.components.count >= 2 {
                            composedWords = [existingWord]
                            showingComposedWords = true
                        } else {
                            selectedWord = existingWord
                            showingEtymology = true
                        }
                    }
                } else {
                    // Mot non trouv√© - cr√©ation
                    await MainActor.run {
                        loadingState = .analyzingWord
                    }
                    
                    let newWord = try await EtymologyOrchestrator.shared.processNewWord(wordToSearch)
                    
                    await MainActor.run {
                        loadingState = .idle
                        addToHistory(wordToSearch)
                        
                        if newWord.isComposedWord && newWord.components.count >= 2 {
                            composedWords = [newWord]
                            showingComposedWords = true
                        } else {
                            selectedWord = newWord
                            showingEtymology = true
                        }
                    }
                }
            } catch {
                await MainActor.run {
                    // Gestion sp√©cifique des diff√©rents types d'erreurs
                    if let cnrtlError = error as? CNRTLError {
                        switch cnrtlError {
                        case .wordNotFound:
                            loadingState = .error("Aucune correspondance trouv√©e pour '\(wordToSearch)'")
                            // Afficher le message "aucun r√©sultat" apr√®s un d√©lai
                            showNoResultAfterDelay()
                        case .sectionNotFound:
                            loadingState = .error("Pas de r√©sultat disponible pour '\(wordToSearch)'")
                            // Afficher le message "aucun r√©sultat" apr√®s un d√©lai
                            showNoResultAfterDelay()
                        default:
                            loadingState = .error("Erreur de connexion lors de la recherche")
                        }
                    } else if let etymologyError = error as? EtymologyError {
                        loadingState = .error(etymologyError.localizedDescription)
                        showNoResultAfterDelay()
                    } else {
                        // V√©rifier les types d'erreurs sp√©cifiques
                        let errorMessage = error.localizedDescription.lowercased()
                        
                        if errorMessage.contains("introuvable") || 
                           errorMessage.contains("non trouv√©") ||
                           errorMessage.contains("not found") {
                            loadingState = .error("Aucune correspondance trouv√©e pour '\(wordToSearch)'")
                            showNoResultAfterDelay()
                        } else if errorMessage.contains("timed out") || errorMessage.contains("timeout") {
                            loadingState = .error("D√©lai d'attente d√©pass√©\nClaude et GPT-5 sont temporairement surcharg√©s.\nR√©essayez dans quelques minutes.")
                        } else if errorMessage.contains("overloaded") {
                            loadingState = .error("Services IA temporairement surcharg√©s\nR√©essayez dans quelques instants.")
                        } else {
                            loadingState = .error("Erreur: \(error.localizedDescription)")
                        }
                    }
                }
            }
        }
    }
    
    private func addToHistory(_ word: String) {
        if !searchHistory.contains(word) {
            searchHistory.insert(word, at: 0)
            if searchHistory.count > 10 {
                searchHistory.removeLast()
            }
            UserDefaults.standard.set(searchHistory, forKey: "searchHistory")
        }
    }
    
    private func loadRemarkableWords() async {
        await MainActor.run {
            isLoadingRemarkableWords = true
        }
        
        do {
            print("üîÑ Chargement des mots remarquables depuis la base...")
            let words = try await SupabaseService.shared.fetchRemarkableWords()
            await MainActor.run {
                remarkableWords = words
                isLoadingRemarkableWords = false
            }
            print("‚úÖ \(words.count) mots remarquables charg√©s")
        } catch {
            print("‚ùå Erreur lors de la r√©cup√©ration des mots remarquables: \(error)")
            await MainActor.run {
                remarkableWords = []
                isLoadingRemarkableWords = false
            }
            print("‚úÖ 0 mots remarquables r√©cup√©r√©s (erreur)")
        }
    }
    
    private func reopenWordFromHistory(_ word: String) async {
        // Mettre √† jour le champ de recherche avec le mot s√©lectionn√©
        await MainActor.run {
            searchText = word
            withAnimation(.easeInOut(duration: 0.3)) {
                isSearchFieldFocused = false
            }
        }
        
        do {
            let foundWord = try await SupabaseService.shared.fetchWord(word)
            
            if let word = foundWord {
                await MainActor.run {
                    addToHistory(word.word)
                    
                    print("üîç DEBUG reopenWordFromHistory - Mot '\(word.word)':")
                    print("   - isComposedWord: \(word.isComposedWord)")
                    print("   - components.count: \(word.components.count)")
                    print("   - components: \(word.components)")
                    
                    if word.isComposedWord && word.components.count >= 2 {
                        print("‚úÖ Affichage ComposedWordsView pour '\(word.word)'")
                        composedWords = [word]
                        showingComposedWords = true
                        print("üîß DEBUG: showingComposedWords = \(showingComposedWords)")
                    } else {
                        print("‚úÖ Affichage EtymologyResultView pour '\(word.word)'")
                        selectedWord = word
                        showingEtymology = true
                    }
                }
            } else {
                // Mot non trouv√© - lancer une nouvelle recherche
                print("‚ö†Ô∏è Mot '\(word)' non trouv√© en base, recherche via orchestrateur...")
                performSearch()
            }
        } catch {
            // En cas d'erreur, lancer une nouvelle recherche
            print("‚ùå Erreur lors de la recherche de '\(word)': \(error)")
            performSearch()
        }
    }

    var body: some View {
        NavigationView {
            ZStack {
                mainScrollView
                
                // Plus de compensation status bar - mode plein √©cran
                
                // Loading maintenant int√©gr√© dans le bloc de recherche
            }
            .navigationTitle("")
            .navigationBarHidden(true)
            // Respect de la safe area pour √©viter de taper dans le menu
            .onTapGesture {
                // Tap en dehors pour d√©focaliser
                if isSearchFieldFocused {
                    withAnimation(.easeInOut(duration: 0.3)) {
                        isSearchFieldFocused = false
                    }
                }
            }
            .onAppear {
                setupOnAppear()
                
                // Connecter le callback de loading pour EtymologyOrchestrator
                EtymologyOrchestrator.shared.onLoadingStateChange = { newState in
                    Task { @MainActor in
                        loadingState = newState
                    }
                }
            }
        }
        .sheet(isPresented: etymologySheetBinding) {
            if let word = selectedWord {
                EtymologyResultView(etymology: word.etymology, word: word)
            }
        }
        .sheet(isPresented: $showingComposedWords) {
            if let composedWord = composedWords.first {
                ComposedWordsView(
                    composedWord: composedWord,
                    isPresented: $showingComposedWords
                )
                .onAppear {
                    print("üîß DEBUG: Sheet ComposedWordsView appel√©e - composedWord: \(composedWord.word)")
                }
            } else {
                Text("Aucun mot compos√©")
                    .onAppear {
                        print("üîß DEBUG: Pas de mots compos√©s √† afficher")
                    }
            }
        }
        .sheet(isPresented: $showingCuration) {
            RemarkableWordsCurationView()
        }
        // SUPPRIM√â: Rechargement automatique apr√®s ajout de nouveaux mots
        // .onReceive(curator.$newWordsAdded) { newWords in
        //     if !newWords.isEmpty {
        //         Task {
        //             await loadRemarkableWords()
        //         }
        //         curator.clearNewWordsNotification()
        //     }
        // }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("CurationViewClosed"))) { _ in
            Task {
                // Forcer le vidage du cache pour √©viter les d√©synchronisations
                await SupabaseService.shared.clearRemarkableWordsCache()
                await loadRemarkableWords()
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("RemarkableWordUpdated"))) { notification in
            Task {
                print("üì® CONTENTVIEW: Notification RemarkableWordUpdated re√ßue!")
                if let userInfo = notification.userInfo, let word = userInfo["word"] as? String, let isRemarkable = userInfo["isRemarkable"] as? Bool {
                    print("üì® CONTENTVIEW: Mot '\(word)' isRemarkable=\(isRemarkable)")
                }
                
                // üîÑ CORRECTION: Attendre la propagation Supabase avant rechargement
                print("‚è≥ CONTENTVIEW: Attente de 1s pour propagation Supabase...")
                try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 seconde
                
                // Vider COMPL√àTEMENT le cache Supabase avant rechargement
                await SupabaseService.shared.clearCache()
                await loadRemarkableWords()
                print("üì® CONTENTVIEW: Rechargement termin√©")
            }
        }
// SUPPRIM√â:         .onReceive(NotificationCenter.default.publisher(for: NSNotification.Name("WordDeleted"))) { _ in
// SUPPRIM√â:             Task {
// SUPPRIM√â:                 await loadRemarkableWords()
// SUPPRIM√â:             }
// SUPPRIM√â:         }
    }
    
    // MARK: - Computed Properties
    private var etymologySheetBinding: Binding<Bool> {
        Binding(
            get: { showingEtymology && selectedWord != nil },
            set: { newValue in 
                if !newValue {
                    showingEtymology = false
                }
            }
        )
    }
    
    private var mainScrollView: some View {
        GeometryReader { geometry in
            ScrollView {
                VStack(spacing: 0) {
                    AppHeaderView()
                    
                    // Spacer pour centrer le champ de recherche (r√©duit)
                    Spacer()
                        .frame(height: max(40, (geometry.size.height - 400) / 4))
                    
                    // Champ de recherche centr√© verticalement
                    searchSection
                    
                    // Espace mod√©r√© avant l'historique  
                    Spacer()
                        .frame(height: max(40, (geometry.size.height - 400) / 6))
                    
                    if !searchHistory.isEmpty {
                        RecentSearchesView(
                            recentSearches: searchHistory,
                            onWordTap: { word in
                                Task {
                                    await reopenWordFromHistory(word)
                                }
                            },
                            onRemove: { word in
                                if let index = searchHistory.firstIndex(of: word) {
                                    searchHistory.remove(at: index)
                                    UserDefaults.standard.set(searchHistory, forKey: "searchHistory")
                                }
                            }
                        )
                        
                        // Espace √©quilibr√© entre historique et mots remarquables
                        Spacer()
                            .frame(height: 16)
                    }
                    
                    RemarkableWordsSection(
                        remarkableWords: remarkableWords,
                        isLoading: isLoadingRemarkableWords,
                        onWordTap: { remarkableWord in
                            Task {
                                await reopenWordFromHistory(remarkableWord.word)
                            }
                        },
                        onEditTap: {
                            showingCuration = true
                        }
                    )
                    .id("remarkable-words-\(remarkableWords.count)-\(remarkableWords.map { $0.id.uuidString }.joined(separator: "-"))")
                    
                    AppFooterView()
                }
                .frame(minHeight: geometry.size.height)
            }
        }
    }
    
    private var searchSection: some View {
        VStack(spacing: 6) {   // R√©duit encore pour ergonomie mobile
            VStack(spacing: 8) {   // Titre plus proche pour compacit√©
                // Titre en dehors du bloc (comme "Origine du mot:")
                Text("Chercher un mot :")
                    .font(.system(size: 16, weight: .light))
                    .foregroundColor(.secondary)
                
                // Zone de texte centr√©e avec bouton X en overlay + loading int√©gr√©
                VStack(spacing: 16) {
                    ZStack {
                        // Zone de texte avec X en overlay (vraiment centr√©)
                        ZStack {
                            // TextField parfaitement centr√© (prend toute la largeur)
                            ZStack {
                                // Placeholder "Rechercher" simple et coh√©rent
                                if !isSearchFieldFocused && searchText.isEmpty && !loadingState.isLoading && !showNoResultMessage {
                                    Text("Rechercher")
                                        .font(.system(size: 40, weight: .light))
                                        .foregroundColor(.secondary.opacity(0.6))  // Meilleur contraste WCAG
                                        .allowsHitTesting(false)
                                        .transition(.opacity.combined(with: .scale(scale: 0.95)))
                                }
                                
                                // TextField pour la saisie
                                TextField("", text: $searchText)
                                    .focused($isSearchFieldFocused)
                                    .font(.system(size: 40, weight: .light))
                                    .foregroundColor(.primary)
                                    .multilineTextAlignment(.center)
                                    .autocapitalization(.none)
                                    .disableAutocorrection(true)
                                    .disabled(loadingState.isLoading)  // D√©sactiver pendant loading
                                    .onSubmit {
                                        performSearch()
                                    }
                                    .onTapGesture {
                                        if !loadingState.isLoading {
                                            withAnimation(.easeInOut(duration: 0.3)) {
                                                isSearchFieldFocused = true
                                            }
                                        }
                                    }
                            }
                            
                            // Bouton X en overlay absolu (ne d√©cale RIEN)
                            if !searchText.isEmpty && !loadingState.isLoading && !showNoResultMessage && loadingState == .idle {
                                HStack {
                                    Spacer()
                                    Button(action: {
                                        searchText = ""
                                    }) {
                                        Image(systemName: "xmark.circle.fill")
                                            .foregroundColor(.gray.opacity(0.6))
                                            .font(.system(size: 18))  // Plus petit pour meilleur alignement
                                    }
                                    .frame(width: 44, height: 44)  // Zone de tap recommand√©e Apple (44pt)
                                    .contentShape(Rectangle())  // Zone de tap rectangulaire plus grande
                                    .offset(y: 2)  // Descendre pour aligner en bout de ligne
                                }
                                .padding(.trailing, 6)
                            }
                        }
                        
                    }
                        
                    // Zone fixe pour loupe OU loading OU message aucun r√©sultat (hauteur constante)
                    ZStack {
                        if showNoResultMessage {
                            // Message "Aucun r√©sultat trouv√©" dans la m√™me zone que les autres messages
                            Text("Aucun r√©sultat trouv√©")
                                .font(.system(size: 15))
                                .foregroundColor(.secondary)
                                .frame(height: 32)  // M√™me hauteur que loading
                        } else if loadingState.isLoading {
                            // Loading √† la place de la loupe
                            HStack(spacing: 8) {
                                ProgressView()
                                    .scaleEffect(0.9)
                                Text(loadingState.message)
                                    .font(.system(size: 15))
                                    .foregroundColor(.secondary)
                                    .lineLimit(1)
                                    .minimumScaleFactor(0.8)
                            }
                            .frame(height: 32)  // Hauteur fixe
                        } else if case .error = loadingState {
                            // √âtat d'erreur : on ne montre RIEN (pr√©pare pour message "aucun r√©sultat")
                            Spacer()
                                .frame(height: 32)  // Garde la hauteur mais vide
                        } else {
                            // Loupe quand pas de loading
                            Button(action: {
                                performSearch()
                            }) {
                                Image(systemName: "magnifyingglass")
                                    .font(.title2)
                                    .foregroundColor(.secondary.opacity(0.6))  // M√™me gris que placeholder
                            }
                            .frame(height: 32)  // M√™me hauteur fixe
                            .disabled(searchText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                            // Pas d'opacity suppl√©mentaire pour garder bon contraste
                        }
                    }
                        
                }
                .padding(.horizontal, 20)  // M√äME padding interne que les cartes
                .padding(.vertical, 32)    // Plus haut que les cartes pour int√©grer loading
                .background(
                    RoundedRectangle(cornerRadius: 20)
                        .fill(
                            (colorScheme == .dark ? Color(UIColor.systemGray6) : Color.white)
                                .shadow(.inner(
                                    color: colorScheme == .dark ? .white.opacity(0.2) : .black.opacity(0.1),
                                    radius: 15,  // M√äME radius que les cartes
                                    x: 0,
                                    y: 8
                                ))
                        )
                )
                .ignoresSafeArea(.keyboard)  // Bloc fixe quand clavier appara√Æt
                // HITBOX √âTENDUE : Tap sur tout le rectangle lance la recherche
                .contentShape(RoundedRectangle(cornerRadius: 20))
                .onTapGesture {
                    // Prioriser focus si vide, sinon rechercher
                    if searchText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        withAnimation(.easeInOut(duration: 0.3)) {
                            isSearchFieldFocused = true
                        }
                    } else if !loadingState.isLoading {
                        performSearch()
                    }
                }
                
                Spacer()

            }
            .padding(.horizontal, 24)  // M√äME que les cartes : 24px des bords
            .padding(.top, 16)      // R√©duit encore pour ergonomie mobile optimale
            .padding(.bottom, 4)    // Espace vraiment r√©duit pour remonter historique
        }
    }
    
    private func showNoResultAfterDelay() {
        // Afficher le message "aucun r√©sultat" PLUS RAPIDEMENT
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            // CUT simple sans animation de fondu
            showNoResultMessage = true
            // NE PAS changer loadingState ici pour √©viter flash loupe/X
            
            // Reset complet apr√®s affichage du message (1.5 secondes)
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                showNoResultMessage = false
                loadingState = .idle  // Reset loadingState SEULEMENT √† la fin
                // Vider le champ pour repartir proprement
                searchText = ""
            }
        }
    }
    
    // MARK: - Helper Methods
    private func setupOnAppear() {
        // Vider l'historique au d√©marrage
        searchHistory = []
        UserDefaults.standard.set([], forKey: "searchHistory")
        
        // SUPPRIM√â: Focus automatique pour une interface plus sobre
        // DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
        //     isSearchFieldFocused = true
        // }
        
        // Vider le cache puis charger les mots remarquables
        Task {
            await SupabaseService.shared.clearAllCaches()
            await loadRemarkableWords()
        }
    }
    

}

#Preview {
    ContentView()
}